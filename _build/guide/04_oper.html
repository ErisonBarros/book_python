---
redirect_from:
  - "/guide/04-oper"
interact_link: content/guide/04_oper.ipynb
kernel_name: python3
has_widgets: false
title: |-
  Operadores
prev_page:
  url: /guide/03_var.html
  title: |-
    Variáveis
next_page:
  url: /guide/05_cole.html
  title: |-
    Coleções
comment: "***PROGRAMMATICALLY GENERATED, DO NOT EDIT. SEE ORIGINAL FILES IN /content***"
---
<main class="jupyter-page">
<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Operadores">Operadores<a class="anchor-link" href="#Operadores"> </a></h1>
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Operadores-l&#243;gicos">Operadores l&#243;gicos<a class="anchor-link" href="#Operadores-l&#243;gicos"> </a></h2><p>Python oferece três operadores lógicos (<em>booleanos</em>): <strong>or</strong> (ou), <strong>and</strong> (e) e <strong>not</strong> (não). Os primeiros dois operadores (<strong>or</strong> e <strong>and</strong>) recebem dois operandos e retornam um valor lógico <strong>True</strong> (Verdadeiro) ou <strong>False</strong> (Falso). O terceiro operador (<strong>not</strong>) recebe apenas um operando e retorna o valor lógico oposto. A tabela verdade abaixo apresenta os valores retornados pelos operadores para diferentes valores dos operandos.</p>
<table>
<thead><tr>
<th>x</th>
<th style="text-align:center">y</th>
<th style="text-align:right"><strong>not</strong> x</th>
<th style="text-align:right">x <strong>or</strong> y</th>
<th style="text-align:right">x <strong>and</strong> y</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>True</strong></td>
<td style="text-align:center"><strong>True</strong></td>
<td style="text-align:right"><strong>False</strong></td>
<td style="text-align:right"><strong>True</strong></td>
<td style="text-align:right"><strong>True</strong></td>
</tr>
<tr>
<td><strong>True</strong></td>
<td style="text-align:center"><strong>False</strong></td>
<td style="text-align:right"><strong>False</strong></td>
<td style="text-align:right"><strong>True</strong></td>
<td style="text-align:right"><strong>False</strong></td>
</tr>
<tr>
<td><strong>False</strong></td>
<td style="text-align:center"><strong>True</strong></td>
<td style="text-align:right"><strong>True</strong></td>
<td style="text-align:right"><strong>True</strong></td>
<td style="text-align:right"><strong>False</strong></td>
</tr>
<tr>
<td><strong>False</strong></td>
<td style="text-align:center"><strong>False</strong></td>
<td style="text-align:right"><strong>True</strong></td>
<td style="text-align:right"><strong>False</strong></td>
<td style="text-align:right"><strong>False</strong></td>
</tr>
</tbody>
</table>
<p>O operador <strong>or</strong> só retorna <strong>False</strong> se os dois operandos forem falsos, portanto por uma questão de eficiência, Python apenas avalia o segundo operando, se o primeiro for <strong>False</strong>. Por outro lado, o operador <strong>and</strong> só retorna <strong>True</strong> se os dois operandos forem verdadeiros, então Python só avalia o segundo operando se o primeiro for <strong>True</strong>. Por isso, esses operadores são chamados de operadores de curto-circuito e essa característica pode ser usada para otimizar código, colocando operandos menos custosos no lado esquerdo desses operadores.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Operadores-relacionais">Operadores relacionais<a class="anchor-link" href="#Operadores-relacionais"> </a></h2><p>O(a) usuário(a) de Python tem oito operadores de comparação (operadores relacionais) a sua disposição, descritos na Tabela abaixo. Os dois últimos operadores são casos especiais de igualdade e diferença para objetos que investigaremos mais à frente no livro. Também veremos mais à frente que objetos de diferentes tipos (exceto números) nunca serão iguais</p>
<table>
<thead><tr>
<th>Operador</th>
<th>Significado</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;, &gt;</td>
<td>menor/maior que</td>
</tr>
<tr>
<td>&lt;=, &gt;=</td>
<td>menor/maior ou igual a</td>
</tr>
<tr>
<td>==, !=</td>
<td>igual/diferente</td>
</tr>
<tr>
<td><strong>is</strong>, <strong>is</strong> <strong>not</strong></td>
<td>igualdade/diferença de objetos</td>
</tr>
</tbody>
</table>
<p>Comparações podem ser encadeadas livremente, o que permite verificar, por exemplo, se o valor de uma variável <em>y</em> cai dentro do intervalo <em>(0, 3]</em> da seguinte maneira:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>

<span class="mi">0</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">3</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>True</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>O código acima é equivalente ao código abaixo, que corresponde a uma forma mais comum em outras linguagens de programação. No entanto, no formato encadeado acima, a variável <em>y</em> é avaliada apenas uma vez, o que produz um código mais eficiente. Além disso, como essas comparações incluem um <strong>and</strong>, a segunda parte (<em>y &lt;= 3</em>) só será avaliada se a primeira (<em>0 &lt; y</em>) for <strong>True</strong>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">3</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>True</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Operadores-aritm&#233;ticos">Operadores aritm&#233;ticos<a class="anchor-link" href="#Operadores-aritm&#233;ticos"> </a></h2><p>Python suporta diferentes tipos de números, mas os principais são os inteiros (<strong>int</strong>) e pontos flutuantes (<strong>float</strong>). Além disso, valores lógicos (<strong>bool</strong>) são um subtipo dos inteiros, com <strong>True</strong> equivalendo a <em>1</em> e <strong>False</strong> a <em>0</em>. Tipos númericos diferentes podem ser usados em uma mesma operação aritmética, com a resposta pertencendo ao tipo mais geral. Os operadores aritméticos incluem:</p>
<table>
<thead><tr>
<th>Operador</th>
<th>Exemplo</th>
<th>Resultado</th>
</tr>
</thead>
<tbody>
<tr>
<td>x + y</td>
<td>1 + 2</td>
<td>3</td>
</tr>
<tr>
<td>x + y</td>
<td>True + 2</td>
<td>3</td>
</tr>
<tr>
<td>x - y</td>
<td>2 - 1.2</td>
<td>0.8</td>
</tr>
<tr>
<td>x * y</td>
<td>2 * 1e-1</td>
<td>0.2</td>
</tr>
<tr>
<td>x / y</td>
<td>1 / 2</td>
<td>0.5</td>
</tr>
<tr>
<td>x // y</td>
<td>10 // 6</td>
<td>1</td>
</tr>
<tr>
<td>x // y</td>
<td>7 // 2</td>
<td>3</td>
</tr>
<tr>
<td>x % y</td>
<td>7 % 2</td>
<td>1</td>
</tr>
<tr>
<td>x % y</td>
<td>6 % 2</td>
<td>0</td>
</tr>
<tr>
<td>x ** y</td>
<td>6 **2</td>
<td>36</td>
</tr>
<tr>
<td>-x</td>
<td>-6</td>
<td>-6</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Prioridade-de-operadores">Prioridade de operadores<a class="anchor-link" href="#Prioridade-de-operadores"> </a></h2><p>Assim como na matemática, operadores seguem uma ordem de precedência. Naturalmente, é possível realizar operações na ordem desejada com o uso de parênteses. A tabela abaixo apresenta os operadores em ordem crescente de precedência, com operadores na mesma linha recebendo a mesma prioridade. Alguns desses operadores ainda serão vistos neste material.</p>
<table>
<thead><tr>
<th>Operador</th>
<th>Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>lambda</strong></td>
<td>Expressões lambda</td>
</tr>
<tr>
<td><strong>if - else</strong></td>
<td>Expressões condicionais</td>
</tr>
<tr>
<td><strong>or</strong></td>
<td>OU lógico</td>
</tr>
<tr>
<td><strong>and</strong></td>
<td>E lógico</td>
</tr>
<tr>
<td><strong>not</strong></td>
<td>NÃO lógico</td>
</tr>
<tr>
<td><strong>in</strong>, <strong>not in</strong>, <strong>is</strong>, <strong>is not</strong>, &lt;, &lt;=, &gt;, &gt;=, !=, ==</td>
<td>Comparações/pertencimento/identidade</td>
</tr>
<tr>
<td>+, -</td>
<td>Adição/subtração</td>
</tr>
<tr>
<td>*, @, /, //, %</td>
<td>Multiplicações/divisões</td>
</tr>
<tr>
<td>-x</td>
<td>Negativo</td>
</tr>
<tr>
<td>**</td>
<td>Exponenciação</td>
</tr>
<tr>
<td>x[indice]</td>
<td>Indexação de sequências</td>
</tr>
<tr>
<td>(expressao)</td>
<td>Expressões entre parênteses</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>

 


</main>
