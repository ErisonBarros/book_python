---
redirect_from:
  - "/guide/04-oper"
interact_link: content/guide/04_oper.ipynb
kernel_name: python3
has_widgets: false
title: |-
  Operadores
prev_page:
  url: /guide/03_ident.html
  title: |-
    Nomes e Identificadores
next_page:
  url: 
  title: |-
    
comment: "***PROGRAMMATICALLY GENERATED, DO NOT EDIT. SEE ORIGINAL FILES IN /content***"
---
<main class="jupyter-page">
<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Operadores">Operadores<a class="anchor-link" href="#Operadores"> </a></h1>
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Operadores-l&#243;gicos">Operadores l&#243;gicos<a class="anchor-link" href="#Operadores-l&#243;gicos"> </a></h3><p>Python oferece três operadores lógicos: <strong>or</strong> (ou), <strong>and</strong> (e) e <strong>not</strong> (não). Os primeiros dois operadores (<strong>or</strong> e <strong>and</strong>) recebem dois operandos e retornam um valor binário <strong>True</strong> (Verdadeiro) ou <strong>False</strong> (Falso). O terceiro operador (<strong>not</strong>) recebe apenas um operando e retorna o valor binário oposto. A tabela verdade abaixo apresenta os valores retornados pelos operadores para diferentes valores dos operandos.</p>
<table>
<thead><tr>
<th>x</th>
<th style="text-align:center">y</th>
<th style="text-align:right"><strong>not</strong> x</th>
<th style="text-align:right">x <strong>or</strong> y</th>
<th style="text-align:right">x <strong>and</strong> y</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>True</strong></td>
<td style="text-align:center"><strong>True</strong></td>
<td style="text-align:right"><strong>False</strong></td>
<td style="text-align:right"><strong>True</strong></td>
<td style="text-align:right"><strong>True</strong></td>
</tr>
<tr>
<td><strong>True</strong></td>
<td style="text-align:center"><strong>False</strong></td>
<td style="text-align:right"><strong>False</strong></td>
<td style="text-align:right"><strong>True</strong></td>
<td style="text-align:right"><strong>False</strong></td>
</tr>
<tr>
<td><strong>False</strong></td>
<td style="text-align:center"><strong>True</strong></td>
<td style="text-align:right"><strong>True</strong></td>
<td style="text-align:right"><strong>True</strong></td>
<td style="text-align:right"><strong>False</strong></td>
</tr>
<tr>
<td><strong>False</strong></td>
<td style="text-align:center"><strong>False</strong></td>
<td style="text-align:right"><strong>True</strong></td>
<td style="text-align:right"><strong>False</strong></td>
<td style="text-align:right"><strong>False</strong></td>
</tr>
</tbody>
</table>
<p>O operador <strong>or</strong> só retorna <strong>False</strong> se os dois operandos forem falsos, portanto por uma questão de eficiência, Python apenas avalia o segundo operando, se o primeiro for <strong>False</strong>. Por outro lado, o operador <strong>and</strong> só retorna <strong>True</strong> se os dois operandos forem verdadeiros, então Python só avalia o segundo operando se o primeiro for <strong>True</strong>. Por isso, esses operadores são chamados de operadores de curto-circuito e essa característica pode ser usada para otimizar código, colocando operandos menos custosos no lado esquerdo desses operadores.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Operadores-relacionais">Operadores relacionais<a class="anchor-link" href="#Operadores-relacionais"> </a></h3><p>There are eight comparison operations in Python. They all have the same priority (which is higher than that of the Boolean operations). Comparisons can be chained arbitrarily; for example, x &lt; y &lt;= z is equivalent to x &lt; y and y &lt;= z, except that y is evaluated only once (but in both cases z is not evaluated at all when x &lt; y is found to be false).</p>
<p>This table summarizes the comparison operations:</p>
<p>Operation</p>
<p>Meaning</p>
<p>&lt;</p>
<p>strictly less than</p>
<p>&lt;=</p>
<p>less than or equal</p>
<p>&gt;</p>
<p>strictly greater than</p>
<blockquote><p>=</p>
</blockquote>
<p>greater than or equal</p>
<p>==</p>
<p>equal</p>
<p>!=</p>
<p>not equal</p>
<p>is</p>
<p>object identity</p>
<p>is not</p>
<p>negated object identity</p>
<p>Objects of different types, except different numeric types, never compare equal. Furthermore, some types (for example, function objects) support only a degenerate notion of comparison where any two objects of that type are unequal. The &lt;, &lt;=, &gt; and &gt;= operators will raise a TypeError exception when comparing a complex number with another built-in numeric type, when the objects are of different types that cannot be compared, or in other cases where there is no defined ordering.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Prioridade-de-operadores">Prioridade de operadores<a class="anchor-link" href="#Prioridade-de-operadores"> </a></h3><p>or                        Boolean OR
and                       Boolean AND
not x                     Boolean NOT
in, not in                Membership tests
is, is not                Identity tests
&lt;, &lt;=, &gt;, &gt;=, &lt;&gt;, !=, ==  Comparisons
|                         Bitwise OR
^                         Bitwise XOR
&amp;                         Bitwise AND
&lt;&lt;, &gt;&gt;                    Shifts
+, -                      Addition and subtraction
*, /, %                   Multiplication, division, remainder
+x, -x                    Positive, negative
~x                        Bitwise not
**                        Exponentiation</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Blocos-e-indenta&#231;&#227;o">Blocos e indenta&#231;&#227;o<a class="anchor-link" href="#Blocos-e-indenta&#231;&#227;o"> </a></h2><p>A principal diferença de Python para outras linguagens, como R, C e Java, é a representação de blocos de código usando níveis de indentação, dispensando o uso de chaves para marcar o início e o fim dos blocos. Essa diferença pode ser vista nos blocos de código abaixo, representando a mesma função para calcular a média aritmética de dois valores. O primeiro código está escrito em R e o segundo contém exatamente a mesma função escrita em Python.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<div class="highlight"><pre><span></span><span class="n">mean</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">result</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span><span class="p">)</span> <span class="o">/</span> <span class="m">2</span>
  <span class="nf">return</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>O uso de indentação para indicar estrutura tem vários benefícios, incluindo:</p>
<ol>
<li>Reduz a necessidade de padrões de código extra: a indentação sempre será de 4 espaços e a IDE usada para escrever o código cuidará de manter essa consistência;</li>
<li>Códigos de diferentes fontes são forçados a seguir o mesmo estilo de indentação;</li>
<li>Reduz trabalho, pois não é necessário se preocupar com o padrão das chaves <strong>e</strong> da indentação;</li>
<li>Mantém um código mais limpo;</li>
<li>O código só executará se a indentação estiver correta, portanto, se o código parece correto, ele está correto;</li>
<li>Não há como confundir escopos de blocos de código aninhados.</li>
</ol>

</div>
</div>
</div>
</div>

 


</main>
